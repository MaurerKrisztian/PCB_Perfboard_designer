<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }

        #canvas-container {
            border: 1px solid #d3d3d3;
            border-radius: 5px;
            overflow: hidden;
        }

        #myCanvas {
            display: block;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            padding: 1em;
            background-color: #fff;
        }

        #controls button {
            padding: 0.5em 1em;
            border: none;
            border-radius: 5px;
            background-color: #008CBA; /* Blue */
            color: white;
            cursor: pointer;
        }

        #controls button:hover {
            background-color: #006994; /* Darker blue */
        }

        #dotDescription {
            margin-top: 1em;
            font-size: 1.2em;
            color: #333;
        }
    </style>
</head>
<body>
<div id="canvas-container">
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <div id="controls">
        <button id="addDescriptionBtn">Add Description</button>
        <button id="deleteDescriptionBtn">Delete Description</button>
        <input type="color" id="colorPicker" style="display:none">
        <button id="changeLineColorBtn">Change Line Color</button>
        <button id="deleteLineBtn">Delete Line</button>
        <button id="changeDotColorBtn">Change Dot Color</button>
        <button id="backBtn">Back</button>
        <button id="forwardBtn">Forward</button>
        <button id="downloadBtn">Download</button>

        <input type="number" id="dotMatrixWidth" min="1" value="10">
        <input type="number" id="dotMatrixHeight" min="1" value="10">
        <button id="resizeGridBtn">Resize Grid</button>

        <button id="saveProgressBtn">Save Progress</button>
        <button id="saveProjectBtn">Save Project</button>
        <input type="file" id="loadProjectBtn" style="display:none">
        <button id="loadProjectTrigger">Load Project</button>
    </div>
    <p id="dotDescription"></p>
</div>

<script>

    const widthInput = document.getElementById('dotMatrixWidth');
    const heightInput = document.getElementById('dotMatrixHeight');
    const resizeBtn = document.getElementById('resizeGridBtn');

    resizeBtn.addEventListener('click', function() {
        let width = parseInt(widthInput.value);
        let height = parseInt(heightInput.value);

        // Set the width and height of the grid
        gridWidth = width;
        gridHeight = height;

        // Recreate the dot grid
        createDotGrid(gridWidth, gridHeight);

        // Clear all lines and redraw the canvas
        lines = [];
        redrawCanvas();
    });


    const saveBtn = document.getElementById('saveProjectBtn');
    const loadInput = document.getElementById('loadProjectBtn');
    const loadTrigger = document.getElementById('loadProjectTrigger');

    saveBtn.addEventListener('click', function() {
        // Convert the state of the canvas to a string (in JSON format)
        var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({dots: dots, lines: lines}));

        // Create a download link and click it
        var downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "canvas_project.json");
        document.body.appendChild(downloadAnchorNode); // required for firefox
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    });

    loadTrigger.addEventListener('click', function() {
        loadInput.click();
    });

    loadInput.addEventListener('change', function(e) {
        var file = e.target.files[0];

        if (!file) return;

        var reader = new FileReader();
        reader.onload = function(e) {
            var contents = e.target.result;
            var data = JSON.parse(contents);

            // Load the state of the canvas from the uploaded file
            dots = data.dots;
            lines = data.lines;

            // Redraw the canvas
            redrawCanvas();
        };
        reader.readAsText(file);
    });




    // Save progress to localStorage
    const saveProgressBtn = document.getElementById('saveProgressBtn');

    saveProgressBtn.addEventListener('click', function() {
        localStorage.setItem('canvasDots', JSON.stringify(dots));
        localStorage.setItem('canvasLines', JSON.stringify(lines));
        alert('Project saved to local storage.');
    });

    // Load progress from localStorage
    window.addEventListener('DOMContentLoaded', (event) => {
        if(localStorage.getItem('canvasDots') !== null && localStorage.getItem('canvasLines') !== null) {
            dots = JSON.parse(localStorage.getItem('canvasDots'));
            lines = JSON.parse(localStorage.getItem('canvasLines'));
            redrawCanvas();
        }
    });



    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    // Dot details
    var dotRadius = 5;
    var distance = 50;

    // Store the dot coordinates
    var dots = [];

    // Store lines
    var lines = [];

    // Store changes for undo and redo
    var changes = [];
    var changeIndex = -1;



    function createDotGrid(width, height) {
        // Calculate the spacing based on the canvas size and the number of dots
        let xSpacing = c.width / width;
        let ySpacing = c.height / height;

        dots = [];
        for(let x = xSpacing / 2; x < c.width; x += xSpacing){
            for(let y = ySpacing / 2; y < c.height; y += ySpacing){
                dots.push({x: x, y: y, description: null, color: "#000"});
            }
        }
    }

    // Create initial dot grid
    createDotGrid(parseInt(widthInput.value), parseInt(heightInput.value));




    // Draw dots and store their positions
    for(var x = distance / 2; x < c.width; x += distance){
        for(var y = distance / 2; y < c.height; y += distance){
            dots.push({x: x, y: y, description: null, color: "#000"});
            ctx.beginPath();
            ctx.arc(x, y, dotRadius, 0, Math.PI*2);
            ctx.fillStyle = "#000";
            ctx.fill();
        }
    }

    // Store selected dot
    var selectedDot = null;

    // Store selected line
    var selectedLine = null;

    // Store hover dot
    var hoverDot = null;

    // Store hover line
    var hoverLine = null;

    // Add the event listener for mousedown.
    c.addEventListener('mousedown', function(e) {
        getCursorPosition(c, e);
    })

    // Add the event listener for mousemove.
    c.addEventListener('mousemove', function(e) {
        const rect = c.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Check if mouse is within a dot
        hoverDot = null;
        for(let i = 0; i < dots.length; i++) {
            var dot = dots[i];
            var dx = x - dot.x;
            var dy = y - dot.y;
            if(dx * dx + dy * dy < dotRadius * dotRadius){
                hoverDot = dot;
                break;
            }
        }

        // Check if mouse is within a line
        hoverLine = null;
        for(let i = 0; i < lines.length; i++) {
            var line = lines[i];
            var dx1 = line.start.x - x;
            var dy1 = line.start.y - y;
            var dx2 = line.end.x - x;
            var dy2 = line.end.y - y;
            var d1 = Math.sqrt(dx1*dx1 + dy1*dy1); // distance from start dot to point
            var d2 = Math.sqrt(dx2*dx2 + dy2*dy2); // distance from end dot to point
            var d = Math.sqrt(Math.pow(line.end.x-line.start.x, 2) + Math.pow(line.end.y-line.start.y, 2)); // distance from start dot to end dot
            if (Math.abs(d - (d1 + d2)) < 10) { // increased tolerance to 10
                hoverLine = line;
                break;
            }
        }


        redrawCanvas();
        if(hoverDot && hoverDot.description){
            document.getElementById('dotDescription').innerText = hoverDot.description;
        } else {
            document.getElementById('dotDescription').innerText = '';
        }
    })

    function getCursorPosition(canvas, event) {
        const rect = canvas.getBoundingClientRect()
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // Check if click is within a dot
        for(let i = 0; i < dots.length; i++) {
            var dot = dots[i];
            var dx = x - dot.x;
            var dy = y - dot.y;
            if(dx * dx + dy * dy < dotRadius * dotRadius){
                if(selectedDot && selectedDot != dot){
                    // Draw a line
                    var newLine = {start: selectedDot, end: dot, color: "#000"};
                    lines.push(newLine);
                    // Store change
                    changes.splice(changeIndex + 1);
                    changes.push({type: 'add', line: newLine});
                    changeIndex++;
                    // Reset selection
                    selectedDot = null;
                    selectedLine = newLine;
                    redrawCanvas();
                } else {
                    // Select this dot
                    selectedDot = dot;
                    selectedLine = null;
                    redrawCanvas();
                }
                return;
            }
        }

// Check if click is within a line
        for(let i = 0; i < lines.length; i++) {
            var line = lines[i];
            var dx1 = line.start.x - x;
            var dy1 = line.start.y - y;
            var dx2 = line.end.x - x;
            var dy2 = line.end.y - y;
            var d1 = Math.sqrt(dx1*dx1 + dy1*dy1); // distance from start dot to point
            var d2 = Math.sqrt(dx2*dx2 + dy2*dy2); // distance from end dot to point
            var d = Math.sqrt(Math.pow(line.end.x-line.start.x, 2) + Math.pow(line.end.y-line.start.y, 2)); // distance from start dot to end dot
            if (Math.abs(d - (d1 + d2)) < 5) {
                selectedLine = line;
                selectedDot = null;
                redrawCanvas();
                return;
            }
        }


        // Click is in empty space, reset selection
        selectedDot = null;
        selectedLine = null;
        redrawCanvas();
    }

    function redrawCanvas() {
        // Clear canvas
        ctx.clearRect(0, 0, c.width, c.height);

        // Draw dots
        for(let i = 0; i < dots.length; i++) {
            var dot = dots[i];
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dotRadius, 0, Math.PI*2);
            ctx.fillStyle = dot.color;
            ctx.fill();
            if(dot == selectedDot){
                ctx.strokeStyle = "#00f";
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            if(dot.description){
                ctx.font = "10px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = dot.color;
                ctx.fillText(dot.description, dot.x, dot.y + dotRadius + 10);
            }
        }

        // Draw lines
        for(let i = 0; i < lines.length; i++) {
            var line = lines[i];
            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = line.color;
            ctx.lineWidth = (line == selectedLine) ? 5 : (line == hoverLine) ? 3 : 1;
            ctx.stroke();
        }
    }
    // Add description
    document.getElementById('addDescriptionBtn').addEventListener('click', function() {
        if(selectedDot){
            let description = prompt("Enter a description for the dot");
            selectedDot.description = description;
            selectedDot = null;
            redrawCanvas();
        } else {
            alert("Please select a dot first by clicking on it");
        }
    });

    // Delete description
    document.getElementById('deleteDescriptionBtn').addEventListener('click', function() {
        if(selectedDot){
            selectedDot.description = null;
            redrawCanvas();
        } else {
            alert("Please select a dot first by clicking on it");
        }
    });

    // Change line color
    document.getElementById('changeLineColorBtn').addEventListener('click', function() {
        document.getElementById('colorPicker').onchange = function() {
            if(selectedLine){
                selectedLine.color = this.value;
                redrawCanvas();
            }
        }
        document.getElementById('colorPicker').click();
    });

    // Delete line
    document.getElementById('deleteLineBtn').addEventListener('click', function() {
        if(selectedLine){
            let index = lines.indexOf(selectedLine);
            if(index > -1){
                // Store change
                changes.splice(changeIndex + 1);
                changes.push({type: 'remove', line: selectedLine});
                changeIndex++;
                // Remove line
                lines.splice(index, 1);
                selectedLine = null;
                redrawCanvas();
            }
        } else {
            alert("Please select a line first by clicking on it");
        }
    });

    // Change dot color
    document.getElementById('changeDotColorBtn').addEventListener('click', function() {
        document.getElementById('colorPicker').onchange = function() {
            if(selectedDot){
                selectedDot.color = this.value;
                redrawCanvas();
            }
        }
        document.getElementById('colorPicker').click();
    });

    // Back button
    document.getElementById('backBtn').addEventListener('click', function() {
        if(changeIndex >= 0){
            var change = changes[changeIndex];
            if(change.type == 'add'){
                for(let i = 0; i < lines.length; i++) {
                    if(lines[i].start == change.line.start && lines[i].end == change.line.end){
                        lines.splice(i, 1);
                        break;
                    }
                }
            } else if(change.type == 'remove'){
                lines.push(change.line);
            }
            changeIndex--;
            redrawCanvas();
        }
    });

    // Forward button
    document.getElementById('forwardBtn').addEventListener('click', function() {
        if(changeIndex < changes.length - 1){
            changeIndex++;
            var change = changes[changeIndex];
            if(change.type == 'add'){
                lines.push(change.line);
            } else if(change.type == 'remove'){
                for(let i = 0; i < lines.length; i++) {
                    if(lines[i].start == change.line.start && lines[i].end == change.line.end){
                        lines.splice(i, 1);
                        break;
                    }
                }
            }
            redrawCanvas();
        }
    });

    // Download functionality
    document.getElementById('downloadBtn').addEventListener('click', function() {
        var link = document.createElement('a');
        link.download = 'canvas.png';
        link.href = c.toDataURL()
        link.click();
    });
</script>

</body>
</html>

